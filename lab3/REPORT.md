# 第三次实验报告 背包优化问题
## 实验目的
1. 理解01背包问题的概念，掌握贪心、动态规划、回溯等基本思想。
2. 学习并实现01背包问题的主流算法和最优解策略的维护，理解不同算法之间的联系与区别。

## 实验内容
1. 实现以下算法
- 分治法
- 动态规划法
- 贪心法
- 回溯法
- 分支限界法

2. 输出最优解值和最优解策略
3. 进行性能测试和比较

## 实验结果分析

### 随机种子40-运行结果
![lab3运行截图](lab3运行截图.png)

### 1. 小规模测试结果分析 (n=10)

在小规模测试中（n=10，背包容量为185），所有算法都能准确找到最优解，最优值为304。

| 算法名称 | 最优值 | 求解时间(秒) | 是否最优解 |
|---------|-------|------------|----------|
| 分治法   | 304   | 0.000258500 | 是 |
| 动态规划 | 304   | 0.000356600 | 是 |
| 贪心算法 | 304   | 0.000016500 | 是 |
| 回溯法   | 304   | 0.000106200 | 是 |
| 分支限界法 | 304  | 0.000071500 | 是 |

从性能上看，贪心算法在小规模问题上速度最快，而动态规划法相对较慢。所有算法都找到了相同的最优解，最终选择了物品 [1, 3, 4, 5, 9]，总重量为176（未超过背包容量185）。

### 2. 中等规模测试结果分析 (n=50)

在中等规模测试（n=50，背包容量为845）中，仅选择了动态规划、贪心算法和分支限界法进行测试（分治和回溯法在中等规模上计算量过大）：

| 算法名称 | 最优值 | 求解时间(秒) | 是否最优解 |
|---------|-------|------------|----------|
| 动态规划 | 1513  | 0.010285700 | 是 |
| 贪心算法 | 1513  | 0.000025800 | 是 |
| 分支限界法 | 1513 | 0.000281700 | 是 |

在中等规模问题上，所有测试的算法都找到了最优解1513。贪心算法仍然表现出最快的求解速度，比动态规划快约400倍，比分支限界法快约10倍。最优解选择了24个物品，总重量为843（非常接近背包容量845）。

### 3. 大规模测试结果分析 (n=200)

大规模测试（n=200，背包容量为3286）中，仅选择动态规划和贪心算法用于测试：

| 算法名称 | 最优值 | 求解时间(秒) | 是否最优解 |
|---------|-------|------------|----------|
| 动态规划 | 6617  | 0.166636300 | 是 |
| 贪心算法 | 6615  | 0.000099500 | 否 |

在大规模问题上，我们观察到：
1. 动态规划算法获得了真正的最优解6617，但耗时显著增加（约0.167秒）
2. 贪心算法虽然速度非常快（约0.0001秒），但得到的解6615略低于最优解，说明贪心策略在大规模问题上不能保证最优性
3. 动态规划算法的解完全利用了背包容量（3286/3286），而贪心算法的解为3284/3286，略有浪费，也是导致非最优解的原因

### 综合分析与结论

1. **算法结构对比**：
   - **分治法**：将问题递归地分解为子问题，通过递归树探索所有可能的解空间。对于背包问题，分治算法考虑每个物品的"选"与"不选"两种状态，最终从中选择最优结果。算法使用了记忆化来避免重复计算。
   - **动态规划**：通过构建一个二维表格dp[i][w]（i表示前i个物品，w表示容量），保存子问题的最优解。每个单元格表示在给定条件下能获得的最大价值。同时使用selected数组记录选择决策，用于回溯找出选择的物品。
   - **贪心算法**：按照物品的单位重量价值（价值/重量）降序排列，依次选择能放入背包的物品。虽然实现简单高效，但不总是能保证得到最优解，特别是在大规模问题上。
   - **回溯法**：通过深度优先搜索探索解空间，对每个物品考虑"选"或"不选"两种决策。回溯法维护当前已选物品、当前重量和价值，并在满足条件时更新最优解。
   - **分支限界法**：通过广度优先搜索并结合上界剪枝策略，按照单位重量价值对物品排序，并计算上界值。采用分数背包思想计算上界，有效剪枝提高效率。维护一个按上界值排序的队列，优先处理更有希望的节点。

2. **算法效率比较**：
   - 贪心算法在所有规模问题上都表现出最高的效率，但是不一定是最优解
   - 动态规划算法可以保证最优解，但随着问题规模增长，其时间复杂度也显著增加
   - 分治法和回溯法仅适用于小规模问题
   - 分支限界法在中小规模问题上表现良好，兼顾了效率和最优性

3. **复杂度增加的原因**：
   - **分治法**：时间复杂度为O(2^n)，因为每个物品有两种状态（选或不选），形成一个二叉递归树。空间复杂度为O(n)，主要是递归栈的深度。随着物品数量增加，计算量呈指数级增长，因此在中大规模问题上无法在合理时间内完成。
   - **动态规划**：时间复杂度为O(n*W)，其中n是物品数量，W是背包容量。空间复杂度也是O(n*W)。随着问题规模增加，尤其是背包容量增大时，计算量和内存需求都会显著增加，但依然可以在合理时间内解决大多数问题。
   - **贪心算法**：时间复杂度为O(n log n)，主要是排序的开销。空间复杂度为O(n)。计算量不会随着背包容量增加而增加，仅与物品数量相关，因此即使在大规模问题上也能保持高效率。
   - **回溯法**：最坏情况下的时间复杂度为O(2^n)，因为需要探索所有可能的组合。空间复杂度为O(n)。与分治法类似，随着物品数量增加，计算量呈指数级增长。
   - **分支限界法**：时间复杂度在最坏情况下为O(2^n)，但通过有效的剪枝策略和优先队列管理，实际计算量通常远小于回溯法。实现中限制了队列大小（最多1000个节点），防止内存占用过大。

4. **最优解质量**（能否找到最优解、能否找到全部最优解）：
   - **分治法**：可以找到最优解，且如果多个组合具有相同的最优值，会保留最后发现的那个。因为完全枚举所有可能性，所以理论上能找到所有最优解，但当前实现只保留一个。
   - **动态规划**：保证找到最优解，当存在多个最优解组合时，会返回一个满足条件的最优解（由选择物品的顺序决定）。不会直接找出所有最优解，但可通过修改实现来实现这一点。
   - **贪心算法**：在某些特殊情况下可以找到最优解（如在我们的中小规模测试中），但不能保证在所有情况下都找到最优解。如大规模测试所示，其解可能略低于真正的最优解。不能找到所有最优解，只能提供一个基于贪心策略的解。
   - **回溯法**：与分治法类似，可以找到最优解，如果有多个最优解组合，会保留最后找到的那个。完全枚举解空间，理论上能找到所有最优解。
   - **分支限界法**：可以找到最优解，但如果多个组合具有相同的最优值，只会返回遇到的第一个。通过队列的管理方式和剪枝策略，不会完全枚举所有可能的最优解。

综上所述，在解决背包问题时，需要根据问题规模和对最优性的要求选择合适的算法。对于小规模问题，任何算法都可以；对于中等规模问题，动态规划和分支限界法是较好的选择；对于大规模问题，如果需要保证最优解，应使用动态规划，如果可以接受近似最优解但要求快速解决，贪心算法则是理想选择。



